from csv import DictReader
from rdflib import Graph, URIRef, Literal, Namespace
from rdflib import RDF, RDFS, OWL, SDO, SKOS
from re import split
from warnings import warn
from ._version import __version__ as version

known_keys = [
    "Type",  # maps to rdfs:type,
    "URI",  # maps to URIRef
    "Label",  # maps to rdfs:label
    "Comment",  # maps to rdfs:comment
    "Usage Note",  # maps to skos:usageNote
    "Domain Includes",  # maps to sdo.domainIncludes
    "Range Includes",  # maps to sdo.rangeIncludes
]

known_types = ["Property", "Class", "Ontology"]

splitters = ", |; |,|;| \n| |\n|,\n|, \n}"  # chars used to separate multiple entries in a cell.


class csv2rdfConverter:
    """Class to read a csv file defining an RDF vocabulary, convert it to an RDF graph and outputas RDF file."""

    def __init__(self):
        self.vocab_rdf = Graph()
        self.namespaces = dict()

    def add_namespace(self, prefix, uri):
        if (type(prefix) == str) and (type(uri) == str):
            if (len(prefix) == 0) or prefix == ":":
                prefix = "default"
            elif (prefix[-1]) == ":":
                prefix = prefix[:-1]
            else:
                prefix = prefix
            self.namespaces[prefix] = uri
        else:
            msg = "Both prefix and URI must be strings."
            raise TypeError(msg)
        return

    def read_csv(self, fname):
        with open(fname, "r") as csv_file:
            csv_reader = DictReader(csv_file)
            self.check_keys(csv_reader.fieldnames)
            for row in csv_reader:
                self.convert_row(row)
        return

    def read_namespaces(self, fname):
        """Load namespaces from a (csv) file."""
        with open(fname, "r") as csv_file:
            csvReader = DictReader(csv_file)
            for row in csvReader:
                if row["prefix"] and row["URI"]:
                    self.add_namespace(row["prefix"], row["URI"])
                elif row["URI"]:
                    self.add_namespace("", row["URI"])
                else:  # pass rows with missing data
                    pass

    def write_out(self, fn: str = "", fmt: str = ""):
        """Write the vocabulary terms definition file."""
        vg = self.vocab_rdf  # vocab graph
        if fmt == "":
            fmt = "turtle"
        if fn:
            try:
                f = open(fn, "w")
            except Exception as e:
                print(f"Could not open file {fn} for writing.")
                raise e
            f.write(f"# RDF generated by CSV2RDF Converter v{version}.")
            f.write("\n")
            f.write(vg.serialize(format=fmt))
            f.close()
        else:
            print(f"\n# RDF generated by CSV2RDF Converter v{version}.")
            print(vg.serialize(format=fmt) + "\n\n")

    def check_keys(self, fields):
        if ("URI" in fields) and ("Type" in fields):
            pass
        else:
            msg = f"Must have columns for Type and URI in the input csv."
            raise ValueError(msg)
        for f in fields:
            if f in known_keys:
                pass
            else:
                msg = f"Cannot convert column {f} to RDF term."
                warn(msg, stacklevel=2)
        return

    def convert_row(self, r: dict):
        vg = self.vocab_rdf
        type = self.process_type(r["Type"])
        term = self.process_term(r["URI"])
        vg.add((term, RDF.type, type))
        # for now will just process RDF/S Properties and Classes.
        # To do: different processing for different types.
        if ("Label" in r.keys()) and (r["Label"] != ""):
            vg.add((term, RDFS.label, Literal(r["Label"])))
        if ("Comment" in r.keys()) and (r["Comment"] != ""):
            vg.add((term, RDFS.comment, Literal(r["Comment"])))
        if ("Usage Note" in r.keys()) and (r["Usage Note"] != ""):
            vg.add((term, SKOS.note, Literal(r["Usage Note"])))
        if ("Domain Includes" in r.keys()) and (r["Domain Includes"] != ""):
            for domain_str in split(splitters, r["Domain Includes"]):
                domain = self.process_term(domain_str)
                vg.add((term, SDO.domainIncludes, domain))
        if ("Range Includes" in r.keys()) and ((r["Range Includes"] != "")):
            for range_str in split(splitters, r["Range Includes"]):
                range = self.process_term(range_str)
                vg.add((term, SDO.rangeIncludes, range))
        return

    def process_type(self, type_str):
        if type_str == "Property":
            type = RDF.Property
        elif type_str == "Class":
            type = RDFS.Class
        elif type_str == "Ontology":
            type = OWL.Ontology
        else:
            msg = f"Unknown term type {type_str}."
            raise ValueError(msg)
        return type

    def process_term(self, cURI):
        try:
            (prefix, name) = cURI.split(":")
        except:
            print(cURI)
            msg = f"{cURI} does not seem to be a curie"
            raise ValueError
        # first make sure the prefix is known and bound to the vocab graph
        if prefix in self.namespaces:
            ns_uriref = URIRef(self.namespaces[prefix])
            if (prefix, ns_uriref) in self.vocab_rdf.namespaces():
                pass
            else:
                ns = Namespace(self.namespaces[prefix])
                self.vocab_rdf.bind(prefix, ns)
        else:
            msg = f"Prefix {prefix} does not correspond to a known namespace."
            raise ValueError(msg)
        # then add the term URI to the graph
        term = URIRef(ns_uriref + name)
        return term
