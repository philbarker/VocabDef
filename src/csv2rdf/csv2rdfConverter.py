from csv import DictReader
from rdflib import Graph, URIRef, Literal, Namespace
from rdflib import RDF, RDFS, OWL, SDO, SKOS
from re import split
from warnings import warn
from otsrdflib import OrderedTurtleSerializer
from ._version import __version__ as version

known_keys = [
    "Type",  # maps to rdfs:type,
    "URI",  # maps to URIRef
    "Label",  # maps to rdfs:label
    "Comment",  # maps to rdfs:comment
    "Usage Note",  # maps to skos:usageNote
    "Domain Includes",  # maps to sdo.domainIncludes
    "Range Includes",  # maps to sdo.rangeIncludes
    "Definition",  # maps to skos:definition
    "Notation",  # maps to skos:notation
    "Related term",  # maps to object of a relationship statement
    "Relationship",  # maps to predicate of a relationship statement
]

known_types = ["Property", "Class", "Ontology", "Concept Scheme", "Concept"]

splitters = (
    ", |; |,|;| \n| |\n|,\n|, \n"  # chars used to separate multiple entries in a cell.
)

serialization_order = [
    OWL.Ontology,
    RDFS.Class,
    RDF.Property,
    SKOS.ConceptScheme,
    SKOS.Concept,
]


class csv2rdfConverter:
    """Class to read a csv file defining an RDF vocabulary, convert it to an RDF graph and outputas RDF file."""

    def __init__(self):
        self.vocab_rdf = Graph()
        self.namespaces = dict()

    def add_namespace(self, prefix, uri):
        if (type(prefix) == str) and (type(uri) == str):
            if (len(prefix) == 0) or prefix == ":":
                prefix = "default"
            elif (prefix[-1]) == ":":
                prefix = prefix[:-1]
            else:
                prefix = prefix
            self.namespaces[prefix] = uri
        else:
            msg = "Both prefix and URI must be strings."
            raise TypeError(msg)
        return

    def read_csv(self, fname):
        with open(fname, "r") as csv_file:
            csv_reader = DictReader(csv_file)
            self.check_keys(csv_reader.fieldnames)
            for row in csv_reader:
                self.convert_row(row)
        return

    def read_namespaces(self, fname):
        """Load namespaces from a (csv) file."""
        with open(fname, "r") as csv_file:
            csvReader = DictReader(csv_file)
            for row in csvReader:
                if row["prefix"] and row["URI"]:
                    self.add_namespace(row["prefix"], row["URI"])
                elif row["URI"]:
                    self.add_namespace("", row["URI"])
                else:  # pass rows with missing data
                    pass

    def write_out(self, fn: str = "", fmt: str = ""):
        """Write the vocabulary terms definition file."""
        vg = self.vocab_rdf  # vocab graph
        if fmt == "":
            fmt = "turtle"
        if fn:  # output to file
            try:
                f = open(fn, "w")
            except Exception as e:
                print(f"Could not open file {fn} for writing.")
                raise e
            f.write(f"# RDF generated by CSV2RDF Converter v{version}.")
            f.write("\n")
            f.close()
            if fmt == "turtle":  # Ordered serializaion...
                serializer = OrderedTurtleSerializer(vg)
                serializer.class_order = serialization_order
                with open(fn, "ab") as f:
                    serializer.serialize(f)
            else:
                with open(fn, "a") as f:
                    f.write(vg.serialize(format=fmt))
        else:  # output to terminal
            print(f"\n# RDF generated by CSV2RDF Converter v{version}.")
            print(vg.serialize(format=fmt))
            print("\n\n")

    def check_keys(self, fields):
        if ("URI" in fields) and ("Type" in fields):
            pass
        else:
            msg = f"Must have columns for Type and URI in the input csv."
            raise ValueError(msg)
        for f in fields:
            if f in known_keys:
                pass
            else:
                msg = f"Cannot convert column {f} to RDF term."
                warn(msg, stacklevel=2)
        return

    def convert_row(self, r: dict):
        vg = self.vocab_rdf
        type = self.process_type(r["Type"].strip())
        term = self.process_term(r["URI"].strip())
        vg.add((term, RDF.type, type))
        # for now will just process RDF/S Properties and Classes.
        # To do: different processing for different types.
        if ("Label" in r.keys()) and (r["Label"].strip() != ""):
            label = r["Label"].strip()
            vg.add((term, RDFS.label, Literal(label)))
        if ("Comment" in r.keys()) and (r["Comment"].strip() != ""):
            comment = r["Comment"].strip()
            vg.add((term, RDFS.comment, Literal(comment)))
        if ("Usage Note" in r.keys()) and (r["Usage Note"].strip() != ""):
            usage = r["Usage Note"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        if ("Domain Includes" in r.keys()) and (r["Domain Includes"].strip() != ""):
            domainList = r["Domain Includes"].strip()
            for domain_str in split(splitters, domainList):
                if domain_str.strip() != "":
                    domain = self.process_term(domain_str.strip())
                    vg.add((term, SDO.domainIncludes, domain))
        if ("Range Includes" in r.keys()) and ((r["Range Includes"].strip() != "")):
            rangeList = r["Range Includes"].strip()
            for range_str in split(splitters, rangeList):
                if range_str.strip() != "":
                    range = self.process_term(range_str.strip())
                    vg.add((term, SDO.rangeIncludes, range))
        return

    def process_type(self, type_str):
        if type_str == "Property":
            type = RDF.Property
        elif type_str == "Class":
            type = RDFS.Class
        elif type_str == "Ontology":
            type = OWL.Ontology
        else:
            msg = f"Unknown term type {type_str}."
            raise ValueError(msg)
        return type

    def process_term(self, cURI):
        try:
            (prefix, name) = cURI.split(":")
        except:
            print(cURI)
            msg = f"{cURI} does not seem to be a curie"
            raise ValueError
        # first make sure the prefix is known and bound to the vocab graph
        if prefix in self.namespaces:
            ns_uriref = URIRef(self.namespaces[prefix])
            if (prefix, ns_uriref) in self.vocab_rdf.namespaces():
                pass
            else:
                ns = Namespace(self.namespaces[prefix])
                self.vocab_rdf.bind(prefix, ns)
        else:
            msg = f"Prefix {prefix} does not correspond to a known namespace."
            raise ValueError(msg)
        # then add the term URI to the graph
        term = URIRef(ns_uriref + name.strip())
        return term
